"""
=============================================================================
             Definición de Schemas (Pydantic) - Tarea 8
=============================================================================

Propósito:
schemas.py define la forma de los datos que tu API envía y recibe, actuando como un filtro de seguridad que valida la información que entra y limpia la información que sale, asegurando que el models.py nunca quede expuesto.

Este archivo define los "Schemas" (esquemas) de datos utilizando Pydantic.
https://www.tutorialesprogramacionya.com/fastapiya/
https://keepcoding.io/blog/como-utilizar-las-type-hints-en-python/
https://www.tutorialesprogramacionya.com/fastapiya/tema9.html

Estos schemas actúan como el "contrato" de la API. Definen la forma exacta
de los datos que:
1.  La API RECIBE (ej. en un POST o PUT).
2.  La API DEVUELVE (ej. en un GET).

FastAPI usa estos schemas para:
-   Validar automáticamente los datos de entrada (ej. asegurar que un 'int' es un 'int').
-   Filtrar los datos de salida (ej. NUNCA devolver el 'hash_contrasena').
-   Generar la documentación automática de la API (en /docs).
"""
# Importamos Pydantic (el validador) y tipos de Python
from pydantic import BaseModel, ConfigDict
from typing import List, Optional # 'Optional' se usa si un campo puede ser Nulo

# --- Schemas para CLIENTE ---

# 1. Schema Base (ClienteBase)
# Define los campos comunes que SÍ queremos exponer al exterior.
# NO incluimos 'hash_contrasena'.
# Aquí se definen los campos que el Usuario debe rellenar. Nunca serials ni datos automáticos.
class ClienteBase(BaseModel):
    nombre_empresa: str
    cif: str # Usaremos este campo para el login (como definimos)
    email_admin: str
    telefono: str
    persona_contacto: str

# 2. Schema de Creación (ClienteCreate)
# Lo que la API necesita para CREAR un cliente (un POST).
# Hereda de ClienteBase y añade la contraseña (en texto plano).
class ClienteCreate(ClienteBase):
    password: str # El usuario nos da una 'password', no el 'hash_contrasena'

# 3. Schema de Lectura (Cliente)
# Lo que la API DEVUELVE al leer un cliente (un GET).
# Hereda de ClienteBase y añade el 'cliente_id'.
# NO incluye 'password' ni 'hash_contrasena' por seguridad.
class Cliente(ClienteBase):
    cliente_id: int
    # parcelas: List[Parcela] = [] # (Descomentaremos esto cuando creemos el Schema 'Parcela')

    # Configuración para que Pydantic entienda el 'models.py' (SQLAlchemy)
    # Le dice a Pydantic que puede leer los datos desde los atributos del ORM.
    model_config = ConfigDict(from_attributes=True)
    
# --- Schemas para LOCALIDAD ---

# 1. Schema Base (Campos Comunes)
# A diferencia de Cliente, aquí SÍ incluimos la PK (codigo_postal),
# porque es un CHAR(5) que el usuario debe proveer, no es un 'serial' automático.
class LocalidadBase(BaseModel):
    codigo_postal: str
    municipio: str
    provincia: str

# 2. Schema de Creación (Input)
# En este caso, es idéntico al Base.
class LocalidadCreate(LocalidadBase):
    pass # No necesita campos extra

# 3. Schema de Lectura (Output)
# Hereda de LocalidadBase y añade la configuración ORM.
class Localidad(LocalidadBase):  
    parcelas: List[Parcela] = [] 
    # Configuración para que Pydantic entienda el 'models.py' (SQLAlchemy)
    model_config = ConfigDict(from_attributes=True)
    
# --- Schemas para PARCELA ---

# 1. Schema Base (Campos Comunes)
# Solo los campos que el usuario debe rellenar
class ParcelaBase(BaseModel):
    ref_catastral: str
    direccion: str

# 2. Schema de Creación (Input)
# En este caso, es idéntico al Base.
class ParcelaCreate(ParcelaBase):
    pass

# 3. Schema de Lectura (Output)
# Lo que la API devuelve. Hereda de la Base y AÑADE los datos generados
# por la BBDD (la PK) y los objetos anidados (Cliente y Localidad).
class Parcela(ParcelaBase):
    parcela_id: int
    
    # --- ANIDACIÓN DE SCHEMAS ---
    # (Como definimos en la lección anterior)
    # Mostramos el objeto Cliente completo, no solo el ID
    cliente: Cliente 
    
    # Mostramos el objeto Localidad completo, no solo el CP
    localidad: Localidad
    
    # (Opcional: Si quisiéramos mostrar los invernaderos de esta parcela)
    invernaderos: List[Invernadero] = []

    # Configuración para que Pydantic entienda el 'models.py' (SQLAlchemy)
    model_config = ConfigDict(from_attributes=True)