=== ARCHIVO: backend/app/crud.py ===


"""
=============================================================================
            Lógica CRUD (Create, Read, Update, Delete)
=============================================================================

Propósito:
Este archivo contiene funciones reutilizables para interactuar con la base de datos.
Actúa como puente entre la API (Routers) y los datos (Models).

Separar esta lógica permite:
1.  Reutilizar código: La función 'get_cliente' sirve para el login y para el perfil.
2.  Testear fácil: Podemos probar estas funciones sin levantar el servidor web.
3.  Limpieza: Los endpoints en 'main.py' o 'routers/' quedan limpios y legibles.

Convención de Nombres:
- get_item(db, id): Obtener uno por ID.
- get_items(db, skip, limit): Obtener lista paginada.
- create_item(db, schema): Crear nuevo.
"""
# --- 1. IMPORTACIONES DE TERCEROS (Librerías externas) ---

# Session: No es para ejecutar código, es para "Type Hinting" (Pistas de Tipo).
# Sirve para que VS Code sepa que la variable 'db' es una conexión a BBDD
# y te autocomplete métodos como .add(), .commit() o .query().
from sqlalchemy.orm import Session

# bcrypt: Librería oficial para hashear contraseñas de forma segura.
import bcrypt


# --- 2. IMPORTACIONES LOCALES (Tu propio código) ---

# Importamos los 'models' (Tablas SQL) para saber DÓNDE guardar los datos.
# Importamos los 'schemas' (Validación Pydantic) para saber QUÉ datos recibimos.
# El punto (.) significa "busca en esta misma carpeta".
from . import models, schemas

# =============================================================================
# 1. LÓGICA PARA CLIENTE
# =============================================================================

"""Busca un cliente ACTIVO por su ID (PK)."""
def get_cliente(db: Session, cliente_id: int):
    # Filtramos por activa=True para que los borrados no aparezcan
    return db.query(models.Cliente).filter(
        models.Cliente.cliente_id == cliente_id, 
        models.Cliente.activa == True
    ).first()

"""
Busca un cliente ACTIVO por su CIF.
IMPORTANTE: Esta función se usará para el LOGIN (Regla de Negocio).
"""
def get_cliente_by_cif(db: Session, cif: str):
    return db.query(models.Cliente).filter(
        models.Cliente.cif == cif, 
        models.Cliente.activa == True
    ).first()

"""Lista paginada de clientes ACTIVOS."""
def get_clientes(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Cliente).filter(
        models.Cliente.activa == True
    ).offset(skip).limit(limit).all()

"""
Crea un nuevo cliente en la base de datos.
PASO CLAVE: Hashear la contraseña usando bcrypt puro.
"""
def create_cliente(db: Session, cliente: schemas.ClienteCreate):
    # 1. Convertir la contraseña a bytes (utf-8)
    password_bytes = cliente.hash_contrasena.encode('utf-8')
    
    # 2. Generar un "Salt" (ruido aleatorio) y hashear la contraseña.
    # bcrypt requiere bytes, por eso hacemos .encode('utf-8')
    salt = bcrypt.gensalt()
    hashed_bytes = bcrypt.hashpw(cliente.hash_contrasena.encode('utf-8'), salt)
    
    # 3. Convertir el hash (que es bytes) a string para guardarlo en PostgreSQL (VARCHAR).
    hashed_password_str = hashed_bytes.decode('utf-8')
    
    # 4. Crear objeto ORM ('activa' será True por defecto)
    db_cliente = models.Cliente(
        nombre_empresa=cliente.nombre_empresa,
        cif=cliente.cif,
        email_admin=cliente.email_admin,
        telefono=cliente.telefono,
        persona_contacto=cliente.persona_contacto,
        hash_contrasena=hashed_password_str # Guardamos el string seguro
    )
    
    # 5. Transacción SQL
    db.add(db_cliente)
    db.commit()
    db.refresh(db_cliente)
    
    return db_cliente

"""
Actualiza los datos de un cliente existente.
Maneja la lógica de seguridad para el cambio de CIF.
"""
def update_cliente(db: Session, cliente_id: int, cliente_update: schemas.ClienteUpdate):
    # 1. Buscar el cliente usando la función segura (que valida si está activo)
    # OPTIMIZACIÓN: Usamos get_cliente en vez de db.query directo para no editar usuarios borrados.
    db_cliente = get_cliente(db, cliente_id)
    
    if not db_cliente:
        return None # No encontrado o está inactivo

    # --- REGLA DE NEGOCIO: CAMBIO DE CIF ---
    # Solo entramos aquí si envían un CIF nuevo Y confirman el cambio
    if cliente_update.cif is not None and cliente_update.confirmar_cambio_cif is True:
        # Verificar que el nuevo CIF no lo tenga ya otro cliente (Duplicado)
        # Nota: Aquí podríamos usar get_cliente_by_cif, pero a veces queremos saber si el CIF existe 
        # incluso en un usuario borrado para no repetir históricos. 
        # De momento usamos la búsqueda estándar.
        otro_cliente = get_cliente_by_cif(db, cliente_update.cif)
        
        if otro_cliente and otro_cliente.cliente_id != cliente_id:
            raise ValueError(f"El CIF {cliente_update.cif} ya está registrado por otro cliente.")
        
        # Si pasa la validación, asignamos el nuevo CIF
        db_cliente.cif = cliente_update.cif

    # 2. Preparar el resto de datos
    # exclude_unset=True: Solo cogemos los campos que el usuario envió en el JSON
    update_data = cliente_update.model_dump(exclude_unset=True)
    
    # Quitamos 'cif' y la confirmación del diccionario porque ya lo gestionamos arriba manualmente
    update_data.pop('cif', None)
    update_data.pop('confirmar_cambio_cif', None)
    
    # 3. Aplicar actualizaciones dinámicas
    for key, value in update_data.items():
        setattr(db_cliente, key, value)
            
    # 4. Guardar cambios
    db.commit()
    db.refresh(db_cliente)
        
    return db_cliente

"""
BORRADO LÓGICO (Soft Delete).
No elimina la fila de la BBDD, solo pone el campo 'activa' a False.
"""
def delete_cliente(db: Session, cliente_id: int):
    # 1. Buscamos el cliente activo
    db_cliente = get_cliente(db, cliente_id)
    
    if db_cliente:
        # 2. Apagamos el interruptor
        db_cliente.activa = False
        db.commit()
        return True # Borrado (desactivado) correctamente
    return False # No existía o ya estaba borrado

# =============================================================================
# 2. LÓGICA PARA LOCALIDAD
# =============================================================================

"""
Busca una localidad por su CP.
Nota: Aquí la PK no es un 'int', es un 'str' (ej: "23700").
"""
def get_localidad(db: Session, codigo_postal: str):
    return db.query(models.Localidad).filter(models.Localidad.codigo_postal == codigo_postal).first()

"""
Registra una nueva localidad.
Al no ser autoincremental, nosotros le pasamos el CP explícitamente.
"""
def create_localidad(db: Session, localidad: schemas.LocalidadCreate):
    db_localidad = models.Localidad(
        codigo_postal=localidad.codigo_postal,
        municipio=localidad.municipio,
        provincia=localidad.provincia
    )
    db.add(db_localidad)
    db.commit()
    db.refresh(db_localidad)
    return db_localidad

"""
Modifica el nombre del municipio o provincia.
Recibe el CP para buscar el registro, pero no permite cambiar el CP en sí.
"""
def update_localidad(db: Session, codigo_postal: str, localidad_update: schemas.LocalidadUpdate):
    # 1. Buscamos por la PK (que es un String)
    db_localidad = db.query(models.Localidad).filter(models.Localidad.codigo_postal == codigo_postal).first()
    
    if not db_localidad:
        return None # No existe

    # 2. Convertimos el esquema a diccionario excluyendo los nulos
    update_data = localidad_update.model_dump(exclude_unset=True)
    
    # 3. Actualizamos campos
    for key, value in update_data.items():
        setattr(db_localidad, key, value)
            
    # 4. Confirmamos cambios
    db.commit()
    db.refresh(db_localidad)
    
    return db_localidad

"""
Devuelve todas las localidades (Para rellenar desplegables en el Frontend).
"""
def get_localidades(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Localidad).offset(skip).limit(limit).all()

"""
Borrado FÍSICO (Hard Delete) de una localidad.
Devuelve True si se borró, False si no existía.
Nota: Esta función fallará (lanzará error de BBDD) si hay parcelas usando este CP.
"""
def delete_localidad(db: Session, codigo_postal: str):
    db_localidad = get_localidad(db, codigo_postal)
    if db_localidad:
        db.delete(db_localidad) # Borrado real de la base de datos
        db.commit()
        return True
    return False

# =============================================================================
# 3. LÓGICA PARA PARCELA
# =============================================================================

"""
Devuelve el listado de todos los terrenos ACTIVOS (paginado).
"""
def get_parcelas(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Parcela).filter(
        models.Parcela.activa == True
    ).offset(skip).limit(limit).all()

"""
Busca UNA parcela ACTIVA por su ID.
"""
def get_parcela(db: Session, parcela_id: int):
    return db.query(models.Parcela).filter(
        models.Parcela.parcela_id == parcela_id, 
        models.Parcela.activa == True
    ).first()

"""
Crea una parcela vinculándola a un Cliente y una Localidad existentes.
Recibe los IDs (FK) en el schema y los pasa al modelo ORM para el INSERT.
"""
def create_parcela(db: Session, parcela: schemas.ParcelaCreate):
    db_parcela = models.Parcela(
        direccion=parcela.direccion,
        ref_catastral=parcela.ref_catastral,
        cliente_id=parcela.cliente_id,      # Enlace al Cliente
        codigo_postal=parcela.codigo_postal, # Enlace a la Localidad
        # activa=True por defecto
    )
    db.add(db_parcela)
    db.commit()
    db.refresh(db_parcela)
    return db_parcela

"""
Actualiza los datos de una parcela.
Restringido: Solo permite cambio de titularidad o corrección de Ref. Catastral.
"""
def update_parcela(db: Session, parcela_id: int, parcela_update: schemas.ParcelaUpdate):
    # 1. Buscar la parcela objetivo (usando get_parcela para asegurar que esté activa)
    db_parcela = get_parcela(db, parcela_id)
    
    if not db_parcela:
        return None # No encontrada o inactiva

    # --- VALIDACIÓN 1: Integridad Referencial (Cambio de Dueño) ---
    # Si hay una compra-venta (cambio de ID cliente), verificamos que el comprador exista.
    if parcela_update.cliente_id is not None:
        # Reutilizamos get_cliente para asegurar que el nuevo dueño también esté activo
        if not get_cliente(db, parcela_update.cliente_id):
            raise ValueError(f"El Cliente (Comprador) {parcela_update.cliente_id} no existe o está inactivo.")

    # --- VALIDACIÓN 2: Regla de Negocio (Ref. Catastral) ---
    # Si quieren corregir la Ref. Catastral (error tipográfico)...
    if parcela_update.ref_catastral is not None and parcela_update.confirmar_cambio_ref is True:
        # Verificar duplicados (que no la tenga ya otra parcela, incluso si está inactiva, para evitar líos históricos)
        otra_parcela = db.query(models.Parcela).filter(models.Parcela.ref_catastral == parcela_update.ref_catastral).first()
        
        if otra_parcela and otra_parcela.parcela_id != parcela_id:
            raise ValueError(f"La Referencia Catastral {parcela_update.ref_catastral} ya pertenece a otra parcela.")
        
        # Asignamos
        db_parcela.ref_catastral = parcela_update.ref_catastral

    # 2. Asignar nuevo dueño si corresponde
    if parcela_update.cliente_id is not None:
        db_parcela.cliente_id = parcela_update.cliente_id

    # 3. Guardar cambios
    db.commit()
    db.refresh(db_parcela)
    
    return db_parcela

"""
BORRADO LÓGICO (Soft Delete).
Desactiva la parcela en lugar de borrarla.
"""
def delete_parcela(db: Session, parcela_id: int):
    # 1. Buscamos la parcela activa
    db_parcela = get_parcela(db, parcela_id)
    
    if db_parcela:
        # 2. Apagamos el interruptor
        db_parcela.activa = False
        db.commit()
        return True
    return False

# =============================================================================
# 4. LÓGICA PARA INVERNADERO
# =============================================================================

"""
Devuelve el listado de todos los invernaderos ACTIVOS (paginado).
CORRECCIÓN: Se usa .filter() para la condición, no dentro de .query().
"""
def get_invernaderos(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Invernadero)\
            .filter(models.Invernadero.activa == True)\
            .offset(skip).limit(limit).all()

"""
Busca un invernadero específico por ID, asegurando que esté activo.
"""
def get_invernadero(db: Session, invernadero_id: int):
    return db.query(models.Invernadero)\
            .filter(models.Invernadero.invernadero_id == invernadero_id, 
                    models.Invernadero.activa == True)\
            .first()

"""
Crea un invernadero vinculándolo a una Parcela existente.
"""
def create_invernadero(db: Session, invernadero: schemas.InvernaderoCreate):
    db_invernadero = models.Invernadero(
        nombre=invernadero.nombre,
        fecha_plantacion=invernadero.fecha_plantacion,
        largo_m=invernadero.largo_m,
        ancho_m=invernadero.ancho_m,
        parcela_id=invernadero.parcela_id,
        cultivo_id=invernadero.cultivo_id
        # 'activa' se pone a True por defecto en la BBDD
    )
    db.add(db_invernadero)
    db.commit()
    db.refresh(db_invernadero)
    return db_invernadero

"""
Actualiza un invernadero (Rotación de cultivos, cambio de nombre o corrección de medidas).
"""
def update_invernadero(db: Session, invernadero_id: int, invernadero_update: schemas.InvernaderoUpdate):
    # 1. Buscar el invernadero (Reutilizamos la función get para asegurar que esté activo)
    db_invernadero = get_invernadero(db, invernadero_id)
    
    if not db_invernadero:
        return None

    # --- VALIDACIÓN: Integridad del Cultivo ---
    # Si nos envían un ID de cultivo (para rotación), comprobamos que exista en el catálogo.
    if invernadero_update.cultivo_id is not None:
        # Nota: get_cultivo debe existir en la sección de cultivos de crud.py
        if not get_cultivo(db, invernadero_update.cultivo_id):
            raise ValueError(f"El Cultivo ID {invernadero_update.cultivo_id} no existe en el catálogo.")

    # 2. Preparar datos (excluyendo nulos)
    update_data = invernadero_update.model_dump(exclude_unset=True)
    
    # 3. Actualizar campos dinámicamente
    for key, value in update_data.items():
        setattr(db_invernadero, key, value)
            
    # 4. Guardar
    db.commit()
    db.refresh(db_invernadero)
    
    return db_invernadero

"""
BORRADO LÓGICO (Soft Delete).
No elimina la fila, solo pone activa = False.
"""
def delete_invernadero(db: Session, invernadero_id: int):
    # Buscamos el invernadero activo
    db_invernadero = get_invernadero(db, invernadero_id)
    
    if db_invernadero:
        db_invernadero.activa = False
        db.commit()
        return True # Borrado exitoso
    return False # No existía o ya estaba borrado

# =============================================================================
# 5. LÓGICA PARA CULTIVO
# =============================================================================
"""
Devuelve un único cultivo buscando por su ID.
"""
def get_cultivo(db: Session, cultivo_id: int):
    return db.query(models.Cultivo).filter(models.Cultivo.cultivo_id == cultivo_id).first()

"""
Busca un cultivo por nombre (ej: "Tomate Pera") para evitar duplicados.
"""
def get_cultivo_by_nombre(db: Session, nombre_cultivo: str):
    return db.query(models.Cultivo).filter(models.Cultivo.nombre_cultivo == nombre_cultivo).first()

"""
Crea un Cultivo en el catálogo.
"""
def create_cultivo(db: Session, cultivo: schemas.CultivoCreate):
    db_cultivo = models.Cultivo(
        nombre_cultivo=cultivo.nombre_cultivo,
        external_api_id=cultivo.external_api_id
    )
    db.add(db_cultivo)
    db.commit()
    db.refresh(db_cultivo)
    return db_cultivo

# =============================================================================
# 6. LÓGICA PARA PARÁMETROS ÓPTIMOS
# =============================================================================

"""
Obtiene TODOS los rangos de parámetros (fases) asociados a un CULTIVO.
Ej: Recibe el ID del Tomate y devuelve: [Fase Germinación, Fase Floración...]
"""
def get_parametros_por_cultivo(db: Session, cultivo_id: int):
    # OJO: Filtramos por 'cultivo_id', no por 'parametro_id'.
    # Usamos .all() porque un cultivo tiene varias fases.
    return db.query(models.ParametrosOptimos).filter(models.ParametrosOptimos.cultivo_id == cultivo_id).all()

"""
Crea un nuevo set de parámetros (una fase nueva para un cultivo).
"""
def create_parametros_optimos(db: Session, parametros: schemas.ParametrosOptimosCreate):
    db_parametros = models.ParametrosOptimos(
        fase_crecimiento=parametros.fase_crecimiento,
        temp_optima_min=parametros.temp_optima_min,
        temp_optima_max=parametros.temp_optima_max,
        humedad_optima_min=parametros.humedad_optima_min,
        humedad_optima_max=parametros.humedad_optima_max,
        necesidad_hidrica=parametros.necesidad_hidrica,
        # FK Importante: Vinculamos estos números a un cultivo padre (ID)
        cultivo_id=parametros.cultivo_id 
    )
    db.add(db_parametros)
    db.commit()
    db.refresh(db_parametros)
    return db_parametros

# =============================================================================
# 7. LÓGICA PARA CATÁLOGOS (TIPOS DE SENSOR/ACTUADOR)
# =============================================================================

"""
Busca un tipo de sensor por nombre (ej: "Temperatura Aire").
Útil para evitar duplicados al inicializar la base de datos.
"""
def get_tipo_sensor_by_nombre(db: Session, nombre_tipo: str):
    return db.query(models.TipoSensor).filter(models.TipoSensor.nombre_tipo == nombre_tipo).first()

"""
Crea un nuevo Tipo de Sensor en el catálogo.
"""
def create_tipo_sensor(db: Session, tipo_sensor: schemas.TipoSensorCreate):
    db_tipo = models.TipoSensor(
        nombre_tipo=tipo_sensor.nombre_tipo,
        unidad_medida=tipo_sensor.unidad_medida
    )
    db.add(db_tipo)
    db.commit()
    db.refresh(db_tipo)
    return db_tipo

"""
Busca un tipo de actuador por nombre (ej: "Electroválvula").
"""
def get_tipo_actuador_by_nombre(db: Session, nombre_tipo: str):
    return db.query(models.TipoActuador).filter(models.TipoActuador.nombre_tipo == nombre_tipo).first()

"""
Crea un nuevo Tipo de Actuador en el catálogo.
"""
def create_tipo_actuador(db: Session, tipo_actuador: schemas.TipoActuadorCreate):
    db_tipo = models.TipoActuador(
        nombre_tipo=tipo_actuador.nombre_tipo
    )
    db.add(db_tipo)
    db.commit()
    db.refresh(db_tipo)
    return db_tipo

# =============================================================================
# 8. LÓGICA PARA SENSORES Y MEDICIONES (IOT)
# =============================================================================

"""
Listado de todos los sensores (instalados o en inventario).
"""
def get_sensores(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Sensor).offset(skip).limit(limit).all()

"""
Registra un nuevo sensor físico (Hardware).
Puede asignarse a un invernadero (campo opcional) o quedarse en stock (None).
"""
def create_sensor(db: Session, sensor: schemas.SensorCreate):
    db_sensor = models.Sensor(
        ubicacion_sensor=sensor.ubicacion_sensor,
        estado_sensor=sensor.estado_sensor,
        tipo_sensor_id=sensor.tipo_sensor_id,   # FK: Qué es
        invernadero_id=sensor.invernadero_id     # FK: Dónde está (puede ser None)
    )
    db.add(db_sensor)
    db.commit()
    db.refresh(db_sensor)
    return db_sensor

"""
Guarda una medición (Dato puro).
IMPORTANTE: No pasamos la fecha, la pone la BBDD automáticamente (server_default).
"""
def create_medicion(db: Session, medicion: schemas.MedicionCreate):
    db_medicion = models.Medicion(
        valor=medicion.valor,
        sensor_id=medicion.sensor_id # FK: Quién midió esto
    )
    db.add(db_medicion)
    db.commit()
    db.refresh(db_medicion)
    return db_medicion

"""
Obtiene el historial de mediciones de un sensor.
Ordenado por fecha DESCENDENTE (lo más nuevo primero) para ver el estado actual rápido.
"""
def get_mediciones_por_sensor(db: Session, sensor_id: int, limit: int = 100):
    return db.query(models.Medicion)\
            .filter(models.Medicion.sensor_id == sensor_id)\
            .order_by(models.Medicion.fecha_hora.desc())\
            .limit(limit).all()

# =============================================================================
# 9. LÓGICA PARA ACTUADORES Y ACCIONES
# =============================================================================

"""
Listado de actuadores.
"""
def get_actuadores(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Actuador).offset(skip).limit(limit).all()

"""
Registra un actuador físico.
Igual que el sensor, puede estar asignado a un invernadero o no.
"""
def create_actuador(db: Session, actuador: schemas.ActuadorCreate):
    db_actuador = models.Actuador(
        ubicacion_actuador=actuador.ubicacion_actuador,
        estado_actuador=actuador.estado_actuador,
        tipo_actuador_id=actuador.tipo_actuador_id,
        invernadero_id=actuador.invernadero_id
    )
    db.add(db_actuador)
    db.commit()
    db.refresh(db_actuador)
    return db_actuador

"""
Guarda en el log qué hizo un actuador.
Ej: "Apertura ventana 50%". Sirve para auditoría.
"""
def create_accion_actuador(db: Session, accion: schemas.AccionActuadorCreate):
    db_accion = models.AccionActuador(
        accion_detalle=accion.accion_detalle,
        actuador_id=accion.actuador_id # FK: Quién se movió
    )
    db.add(db_accion)
    db.commit()
    db.refresh(db_accion)
    return db_accion

# =============================================================================
# 10. LÓGICA PARA RECOMENDACIONES DE RIEGO (IA)
# =============================================================================

"""
Guarda una decisión tomada por el algoritmo de riego inteligente.
"""
def create_recomendacion(db: Session, recomendacion: schemas.RecomendacionRiegoCreate):
    db_recomendacion = models.RecomendacionRiego(
        cantidad_ml=recomendacion.cantidad_ml,
        duracion_min=recomendacion.duracion_min,
        razon_logica=recomendacion.razon_logica,
        invernadero_id=recomendacion.invernadero_id # FK: Dónde regar
    )
    db.add(db_recomendacion)
    db.commit()
    db.refresh(db_recomendacion)
    return db_recomendacion

"""
Historial de riegos recomendados para un invernadero.
Útil para que el agricultor vea por qué se regó ayer.
"""
def get_recomendaciones_por_invernadero(db: Session, invernadero_id: int, limit: int = 50):
    return db.query(models.RecomendacionRiego)\
            .filter(models.RecomendacionRiego.invernadero_id == invernadero_id)\
            .order_by(models.RecomendacionRiego.fecha_recomendacion.desc())\
            .limit(limit).all()



=== ARCHIVO: backend/app/routers/datos_maestros.py ===

"""
===============================================================================================
            Router: Datos Maestros (Clientes, Localidades, Parcelas e Invernaderos)
===============================================================================================

Propósito:
Este archivo define los "Endpoints" (URLs) de la API relacionados con la
estructura base del sistema.

Aquí es donde FastAPI recibe las peticiones HTTP (GET, POST, PUT, DELETE), valida los datos
usando 'schemas.py', llama a la lógica de base de datos en 'crud.py',
y devuelve la respuesta al usuario.
"""

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List

# Importaciones locales del proyecto SIRA
from .. import crud, models, schemas
from ..database import SessionLocal

# --- Configuración del Router ---
# prefix: Todas las URLs empezarán con /api/v1 (convención REST)
# tags: Para agrupar estos endpoints en la documentación automática (Swagger)
router = APIRouter(
    prefix="/api/v1",
    tags=["Datos Maestros (Configuración)"]
)

# --- Dependencia para obtener la DB ---
# Esta función abre una "tubería" a la BBDD para cada petición y la cierra al terminar.
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# =============================================================================
# 1. GESTIÓN DE CLIENTES
# =============================================================================

# 1. POST (Crear)
@router.post("/clientes/", response_model=schemas.Cliente, status_code=status.HTTP_201_CREATED, summary="Crear Cliente")
def crear_cliente(cliente: schemas.ClienteCreate, db: Session = Depends(get_db)):
    """
    Registra una nueva empresa/agricultor en SIRA.
    - Verifica si el CIF ya existe.
    - Hashea la contraseña automáticamente (vía crud).
    """
    db_cliente = crud.get_cliente_by_cif(db, cif=cliente.cif)
    if db_cliente:
        raise HTTPException(status_code=400, detail="El cliente con este CIF ya está registrado.")
    return crud.create_cliente(db=db, cliente=cliente)

# 2. GET (Listar Todos)
@router.get("/clientes/", response_model=List[schemas.Cliente], summary="Listar Clientes")
def listar_clientes(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """Devuelve un listado paginado de clientes registrados."""
    return crud.get_clientes(db, skip=skip, limit=limit)

# 3. GET (Buscar por CIF - ESPECÍFICO)
# ¡IMPORTANTE! Lo ponemos ANTES de buscar por ID para evitar conflictos de rutas y ordenar visualmente.
@router.get("/clientes/buscar/{cif}", response_model=schemas.Cliente, summary="Buscar Cliente por CIF")
def buscar_cliente_por_cif(cif: str, db: Session = Depends(get_db)):
    """
    Permite encontrar un cliente sabiendo su DNI/NIF/CIF.
    Útil para herramientas de administración o validaciones.
    """
    db_cliente = crud.get_cliente_by_cif(db, cif=cif)
    if db_cliente is None:
        raise HTTPException(status_code=404, detail="No existe ningún cliente con este CIF")
    return db_cliente

# 4. GET (Leer por ID - GENÉRICO)
@router.get("/clientes/{cliente_id}", response_model=schemas.Cliente, summary="Leer Cliente")
def leer_cliente(cliente_id: int, db: Session = Depends(get_db)):
    """Busca un cliente específico por su ID interno."""
    db_cliente = crud.get_cliente(db, cliente_id=cliente_id)
    if db_cliente is None:
        raise HTTPException(status_code=404, detail="Cliente no encontrado")
    return db_cliente

# 5. PUT (Actualizar)
@router.put("/clientes/{cliente_id}", response_model=schemas.Cliente, summary="Actualizar Cliente")
def actualizar_cliente(cliente_id: int, cliente_update: schemas.ClienteUpdate, db: Session = Depends(get_db)):
    """
    Modifica los datos de un cliente. 
    Para cambiar el CIF, es obligatorio enviar 'confirmar_cambio_cif': true.
    """
    try:
        db_cliente = crud.update_cliente(db=db, cliente_id=cliente_id, cliente_update=cliente_update)
        if db_cliente is None:
            raise HTTPException(status_code=404, detail="Cliente no encontrado")
        return db_cliente
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

# 6. DELETE (Borrar)
@router.delete("/clientes/{cliente_id}", status_code=status.HTTP_204_NO_CONTENT, summary="Borrar Cliente (Lógico)")
def borrar_cliente(cliente_id: int, db: Session = Depends(get_db)):
    """
    Desactiva un cliente. No borra los datos físicos.
    Devuelve 204 No Content si se realizó correctamente.
    """
    exito = crud.delete_cliente(db, cliente_id=cliente_id)
    if not exito:
        raise HTTPException(status_code=404, detail="Cliente no encontrado o ya borrado")
    return None


# =============================================================================
# 2. GESTIÓN DE LOCALIDADES
# =============================================================================

# Endpoint para dar de alta una nueva localidad
@router.post("/localidades/", response_model=schemas.Localidad, status_code=status.HTTP_201_CREATED, summary="Crear Localidad")
def crear_localidad(localidad: schemas.LocalidadCreate, db: Session = Depends(get_db)):
    """
    Registra una nueva localidad. La PK es el Código Postal.
    """
    # 1. Verificar si el CP ya existe
    db_localidad = crud.get_localidad(db, codigo_postal=localidad.codigo_postal)
    if db_localidad:
        raise HTTPException(status_code=400, detail="Este Código Postal ya existe en la base de datos.")
        
    return crud.create_localidad(db=db, localidad=localidad)

# Endpoint para consultar información de una localidad
@router.get("/localidades/{codigo_postal}", response_model=schemas.Localidad, summary="Leer Localidad")
def leer_localidad(codigo_postal: str, db: Session = Depends(get_db)):
    """Obtiene datos de una localidad dado su CP."""
    db_localidad = crud.get_localidad(db, codigo_postal=codigo_postal)
    if db_localidad is None:
        raise HTTPException(status_code=404, detail="Localidad no encontrada")
    return db_localidad

# Endpoint para corregir errores en localidad
@router.put("/localidades/{codigo_postal}", response_model=schemas.Localidad, summary="Actualizar Localidad")
def actualizar_localidad(codigo_postal: str, localidad_update: schemas.LocalidadUpdate, db: Session = Depends(get_db)):
    """
    Permite cambiar el nombre del Municipio o Provincia.
    El CP es inmutable.
    """
    db_localidad = crud.update_localidad(db=db, codigo_postal=codigo_postal, localidad_update=localidad_update)
    
    if db_localidad is None:
        raise HTTPException(status_code=404, detail="Localidad no encontrada")
        
    return db_localidad

# Endpoint para listar TODAS las localidades
@router.get("/localidades/", response_model=List[schemas.Localidad], summary="Listar Localidades")
def listar_localidades(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """
    Devuelve la lista completa de localidades.
    Útil para que el Frontend muestre un selector de municipios.
    """
    return crud.get_localidades(db, skip=skip, limit=limit)

# Endpoint para borrar localidad
@router.delete("/localidades/{codigo_postal}", status_code=status.HTTP_204_NO_CONTENT, summary="Borrar Localidad")
def borrar_localidad(codigo_postal: str, db: Session = Depends(get_db)):
    """
    Elimina una localidad físicamente.
    
    PROTECCIÓN DE INTEGRIDAD:
    Si la localidad tiene parcelas asignadas, la base de datos bloqueará el borrado
    y devolveremos un error 400 explicativo.
    """
    # 1. Verificar existencia
    if not crud.get_localidad(db, codigo_postal):
        raise HTTPException(status_code=404, detail="Localidad no encontrada")
        
    # 2. Intentar borrar con red de seguridad
    try:
        crud.delete_localidad(db, codigo_postal=codigo_postal)
    except Exception as e:
        # Aquí capturamos el error de PostgreSQL si hay parcelas vinculadas
        raise HTTPException(
            status_code=400, 
            detail="No se puede borrar esta localidad porque existen parcelas registradas en ella. Elimine o mueva las parcelas antes."
        )
    
    return None

# =============================================================================
# 3. GESTIÓN DE PARCELAS
# =============================================================================

# Endpoint para registrar una nueva parcela
@router.post("/parcelas/", response_model=schemas.Parcela, status_code=status.HTTP_201_CREATED, summary="Crear Parcela")
def crear_parcela(parcela: schemas.ParcelaCreate, db: Session = Depends(get_db)):
    """
    Registra un terreno físico.
    Requiere que el Cliente (ID) y la Localidad (CP) existan previamente.
    """
    # 1. Validar integridad referencial (Cliente)
    if not crud.get_cliente(db, cliente_id=parcela.cliente_id):
        raise HTTPException(status_code=404, detail=f"Cliente {parcela.cliente_id} no encontrado.")

    # 2. Validar integridad referencial (Localidad)
    if not crud.get_localidad(db, codigo_postal=parcela.codigo_postal):
        raise HTTPException(status_code=404, detail=f"Código Postal {parcela.codigo_postal} no registrado.")

    # 3. Crear parcela
    try:
        return crud.create_parcela(db=db, parcela=parcela)
    except Exception as e:
        raise HTTPException(status_code=400, detail="Error al crear parcela. Verifique Ref. Catastral.")

# Endpoint para listar parcelas
@router.get("/parcelas/", response_model=List[schemas.Parcela], summary="Listar Parcelas")
def listar_parcelas(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """Lista todas las parcelas."""
    return crud.get_parcelas(db, skip=skip, limit=limit)

# Endpoint para listar parcelas DE UN CLIENTE
@router.get("/parcelas/cliente/{cliente_id}", response_model=List[schemas.Parcela], summary="Listar Parcelas de un Cliente")
def listar_parcelas_cliente(cliente_id: int, db: Session = Depends(get_db)):
    """
    Muestra solo las parcelas propiedad del cliente indicado.
    Ideal para el panel de control del usuario.
    """
    # Primero verificamos que el cliente exista
    if not crud.get_cliente(db, cliente_id):
        raise HTTPException(status_code=404, detail="Cliente no encontrado")
        
    return crud.get_parcelas_por_cliente(db, cliente_id=cliente_id)

# Endpoint para obtener el detalle de una parcela
@router.get("/parcelas/{parcela_id}", response_model=schemas.Parcela, summary="Leer Parcela")
def read_parcela(parcela_id: int, db: Session = Depends(get_db)):
    """Busca una parcela específica por su ID."""
    db_parcela = crud.get_parcela(db, parcela_id=parcela_id)
    if db_parcela is None:
        raise HTTPException(status_code=404, detail="Parcela no encontrada")
    return db_parcela

# Endpoint para actualizar parcela
@router.put("/parcelas/{parcela_id}", response_model=schemas.Parcela, summary="Actualizar Parcela")
def actualizar_parcela(parcela_id: int, parcela_update: schemas.ParcelaUpdate, db: Session = Depends(get_db)):
    """
    Modifica una parcela (Traspaso de dueño o corrección Catastro).
    Dirección y CP son inmutables.
    """
    try:
        db_parcela = crud.update_parcela(db=db, parcela_id=parcela_id, parcela_update=parcela_update)
        
        if db_parcela is None:
            raise HTTPException(status_code=404, detail="Parcela no encontrada")
            
        return db_parcela

    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

# Endpoint para Borrado Lógico de Parcela
@router.delete("/parcelas/{parcela_id}", status_code=status.HTTP_204_NO_CONTENT, summary="Borrar Parcela (Lógico)")
def borrar_parcela(parcela_id: int, db: Session = Depends(get_db)):
    """
    Desactiva una parcela.
    """
    if not crud.delete_parcela(db, parcela_id):
        raise HTTPException(status_code=404, detail="Parcela no encontrada")
    return None


# =============================================================================
# 4. GESTIÓN DE INVERNADEROS
# =============================================================================

# Endpoint para registrar un nuevo invernadero
@router.post("/invernaderos/", response_model=schemas.Invernadero, status_code=status.HTTP_201_CREATED, summary="Crear Invernadero")
def crear_invernadero(invernadero: schemas.InvernaderoCreate, db: Session = Depends(get_db)):
    """
    Registra un invernadero. Valida Parcela y Cultivo.
    """
    # 1. Validar Parcela
    db_parcela = crud.get_parcela(db, parcela_id=invernadero.parcela_id)
    if not db_parcela:
        raise HTTPException(status_code=404, detail=f"La parcela {invernadero.parcela_id} no existe.")

    # 2. Validar Cultivo
    if invernadero.cultivo_id:
        db_cultivo = crud.get_cultivo(db, cultivo_id=invernadero.cultivo_id)
        if not db_cultivo:
            raise HTTPException(status_code=404, detail=f"El cultivo {invernadero.cultivo_id} no existe.")

    return crud.create_invernadero(db=db, invernadero=invernadero)

# Endpoint para listar invernaderos
@router.get("/invernaderos/", response_model=List[schemas.Invernadero], summary="Listar Invernaderos")
def listar_invernaderos(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """Lista los invernaderos registrados."""
    return crud.get_invernaderos(db, skip=skip, limit=limit)

# Endpoint para listar invernaderos DE UN CLIENTE
@router.get("/invernaderos/cliente/{cliente_id}", response_model=List[schemas.Invernadero], summary="Listar Invernaderos de un Cliente")
def listar_invernaderos_cliente(cliente_id: int, db: Session = Depends(get_db)):
    """
    Obtiene todos los invernaderos (naves) que posee un cliente,
    independientemente de en qué parcela estén.
    """
    if not crud.get_cliente(db, cliente_id):
        raise HTTPException(status_code=404, detail="Cliente no encontrado")

    return crud.get_invernaderos_por_cliente(db, cliente_id=cliente_id)

# Endpoint para consultar un invernadero específico por ID
@router.get("/invernaderos/{invernadero_id}", response_model=schemas.Invernadero, summary="Leer Invernadero")
def leer_invernadero(invernadero_id: int, db: Session = Depends(get_db)):
    """
    Recupera los datos de un invernadero concreto.
    Devuelve 404 si no existe o si ha sido borrado (soft delete).
    """
    db_invernadero = crud.get_invernadero(db, invernadero_id=invernadero_id)
    
    if db_invernadero is None:
        raise HTTPException(status_code=404, detail="Invernadero no encontrado")
        
    return db_invernadero

# Endpoint para actualizar invernadero
@router.put("/invernaderos/{invernadero_id}", response_model=schemas.Invernadero, summary="Actualizar Invernadero")
def actualizar_invernadero(invernadero_id: int, invernadero_update: schemas.InvernaderoUpdate, db: Session = Depends(get_db)):
    """
    Modifica nombre, medidas o cultivo (rotación).
    """
    try:
        db_invernadero = crud.update_invernadero(db=db, invernadero_id=invernadero_id, invernadero_update=invernadero_update)
        
        if db_invernadero is None:
            raise HTTPException(status_code=404, detail="Invernadero no encontrado")
            
        return db_invernadero

    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

# Endpoint para Borrado Lógico de Invernadero
@router.delete("/invernaderos/{invernadero_id}", status_code=status.HTTP_204_NO_CONTENT, summary="Borrar Invernadero (Lógico)")
def borrar_invernadero(invernadero_id: int, db: Session = Depends(get_db)):
    """
    Desactiva un invernadero.
    """
    if not crud.delete_invernadero(db, invernadero_id):
        raise HTTPException(status_code=404, detail="Invernadero no encontrado")
    return None
